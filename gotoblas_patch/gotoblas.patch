diff -u -r gotoblas_org/GotoBLAS2/common.h GotoBLAS2/common.h
--- gotoblas_org/GotoBLAS2/common.h	2010-11-05 14:56:22.000000000 +0100
+++ GotoBLAS2/common.h	2011-03-29 11:52:33.922501236 +0200
@@ -410,6 +410,9 @@
 #endif
 
 void goto_set_num_threads(int);
+void caldgemm_goto_reserve_cpus(int);
+void caldgemm_goto_reserve_cpu(int, int);
+void caldgemm_goto_restrict_cpus(int);
 
 void gotoblas_affinity_init(void);
 void gotoblas_affinity_quit(void);
diff -u -r gotoblas_org/GotoBLAS2/common_thread.h GotoBLAS2/common_thread.h
--- gotoblas_org/GotoBLAS2/common_thread.h	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/common_thread.h	2011-03-29 10:58:05.055625469 +0200
@@ -47,6 +47,7 @@
 
 /* Global Parameter */
 extern int blas_cpu_number;
+extern int caldgemm_reserve_cpus;
 extern int blas_num_threads;
 extern int blas_omp_linked;
 
@@ -123,6 +124,7 @@
 #ifdef SMP_SERVER
 
 extern int blas_server_avail;
+extern int caldgemm_restrict_cpus;
 
 static __inline int num_cpu_avail(int level) {
 
diff -u -r gotoblas_org/GotoBLAS2/driver/others/blas_server.c GotoBLAS2/driver/others/blas_server.c
--- gotoblas_org/GotoBLAS2/driver/others/blas_server.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/driver/others/blas_server.c	2011-09-28 18:56:52.232306769 +0200
@@ -42,6 +42,10 @@
 #include <sys/resource.h>
 #endif
 
+//#define SMP_DEBUG
+
+#define MAX_CPUS 256
+
 #ifdef SMP_SERVER
 
 #undef MONITOR
@@ -51,6 +55,8 @@
 
 #define ATTRIBUTE_SIZE 128
 
+extern int reserved_cpu_cores[MAX_CPUS];
+
 /* This is a thread server model implementation.  The threads are   */
 /* spawned at first access to blas library, and still remains until */
 /* destruction routine is called.  The number of threads are        */
@@ -69,6 +75,8 @@
 static unsigned long server_lock       = 0;
 #endif
 
+extern int cpu_mapping[MAX_CPUS];
+
 #define THREAD_STATUS_SLEEP		2
 #define THREAD_STATUS_WAKEUP		4
 
@@ -564,9 +572,15 @@
       /* Node Mapping Mode */
 
       if (queue -> mode & BLAS_NODE) {
-
 	do {
-	  while((thread_status[i].node != node || thread_status[i].queue) && (i < blas_num_threads - 1)) i ++;
+	  while((i < blas_num_threads - 1) && (thread_status[i].node != node || thread_status[i].queue || cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]] ))
+	  {
+	    i ++;
+#ifdef SMP_DEBUG
+	    if (cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]]) printf("Ommiting thread %d\n", i);
+#endif
+	  }
+	  
 	  
 	  if (i < blas_num_threads - 1) break;
 
@@ -578,19 +592,29 @@
 	  }
 
 	} while (1);
+#ifdef SMP_DEBUG
+	printf("Running on CPU with id %d\n", cpu_mapping[i + 1]);
+#endif
 
       } else {
-	while(thread_status[i].queue) {
+	while(thread_status[i].queue || cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]]) {
+#ifdef SMP_DEBUG
+		if (cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]]) printf("Ommiting thread %d\n", i);
+#endif
 	  i ++;
 	  if (i >= blas_num_threads - 1) i = 0;
 	}
       }
 #else
-      while(thread_status[i].queue) {
+        while(thread_status[i].queue || cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]]) {
+#ifdef SMP_DEBUG
+		if (cpu_mapping[i + 1] < caldgemm_reserve_cpus || reserved_cpu_cores[cpu_mapping[i + 1]]) printf("Ommiting thread %d\n", i);
+#endif
 	i ++;
 	if (i >= blas_num_threads - 1) i = 0;
       }
 #endif
+
       
       queue -> assigned = i;
       WMB;
@@ -758,6 +782,21 @@
 
 }
 
+void caldgemm_goto_reserve_cpus(int num_cpus) {
+    int i;
+    caldgemm_reserve_cpus = num_cpus;
+    for (i = 0;i < blas_num_threads;i++) reserved_cpu_cores[i] = 0;
+};
+
+void caldgemm_goto_restrict_cpus(int val)
+{
+    caldgemm_restrict_cpus = val;
+}
+void caldgemm_goto_reserve_cpu(int cpu_id, int val)
+{
+    reserved_cpu_cores[cpu_id] = val;
+}
+
 /* Compatible function with pthread_create / join */
 
 int gotoblas_pthread(int numthreads, void *function, void *args, int stride) {
diff -u -r gotoblas_org/GotoBLAS2/driver/others/init.c GotoBLAS2/driver/others/init.c
--- gotoblas_org/GotoBLAS2/driver/others/init.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/driver/others/init.c	2011-03-29 12:28:57.375500235 +0200
@@ -70,17 +70,19 @@
   int num_nodes;
   int num_procs;
   int final_num_procs;
-  unsigned long avail;
+  unsigned long long int avail;
   
   unsigned long cpu_info   [MAX_CPUS];
-  unsigned long node_info  [MAX_NODES];
+  unsigned long long int node_info  [MAX_NODES];
   int cpu_use[MAX_CPUS];
 
 } shm_t;
 
+int reserved_cpu_cores[MAX_CPUS];
+
 static cpu_set_t cpu_orig_mask[4];
 
-static int  cpu_mapping[MAX_CPUS];
+int cpu_mapping[MAX_CPUS];
 static int  node_mapping[MAX_CPUS * 4];
 static int  cpu_sub_mapping[MAX_CPUS];
 static int  disable_mapping;
@@ -93,7 +95,8 @@
 static int shmid, pshmid;
 static void *paddr;
 
-static unsigned long lprocmask, lnodemask;
+static unsigned long long int lprocmask;
+static unsigned long lnodemask;
 static int numprocs = 1;
 static int numnodes = 1;
 
@@ -139,12 +142,12 @@
   return count;
 }
 
-static inline unsigned long get_cpumap(int node) {
+static inline unsigned long long int get_cpumap(int node) {
 
   int infile;
-  unsigned long affinity;
+  unsigned long long int affinity;
   char name[160];
-  char *p, *dummy;
+  char *p, *pp, *dummy;
   
   sprintf(name, CPUMAP_NAME, node);
   
@@ -154,24 +157,37 @@
     
   if (infile != -1) {
     
-    read(infile, name, sizeof(name));
+    name[read(infile, name, sizeof(name))] = 0;
    
     p = name;
 
+    p[128] = NULL;
     while ((*p == '0') || (*p == ',')) p++;
+    pp = p;
+    pp++;
+    while (*pp != ',' && *pp != 0) pp++;
+    if (*pp == ',')
+    {
+	do
+	{
+	    *pp = *(pp + 1);
+	    pp++;
+	} while (*pp != 0);
+    }
+    
 
-    affinity = strtol(p, &dummy, 16);
-   
+    affinity = strtoll(p, &dummy, 16);
+    
     close(infile);
   }
 
   return affinity;
 }
 
-static inline unsigned long get_share(int cpu, int level) {
+static inline unsigned long long int get_share(int cpu, int level) {
 
   int infile;
-  unsigned long affinity;
+  unsigned long long int affinity;
   char name[160];
   char *p;
   
@@ -179,7 +195,7 @@
   
   infile = open(name, O_RDONLY);
 
-  affinity = (1UL << cpu);
+  affinity = (((unsigned long long int) 1) << cpu);
     
   if (infile != -1) {
     
@@ -189,7 +205,7 @@
 
     while ((*p == '0') || (*p == ',')) p++;
 
-    affinity = strtol(p, &p, 16);
+    affinity = strtoll(p, &p, 16);
    
     close(infile);
   }
@@ -238,7 +254,7 @@
   fprintf(stderr, "Numa found : number of Nodes = %2d\n", common -> num_nodes);
 
   for (node = 0; node < common -> num_nodes; node ++)
-    fprintf(stderr, "MASK (%2d) : %08lx\n", node, common -> node_info[node]);
+    fprintf(stderr, "MASK (%2d) : %08llx\n", node, common -> node_info[node]);
 #endif
 
   return common -> num_nodes;
@@ -254,7 +270,7 @@
   for (node = 0; node < common -> num_nodes; node ++) {
     core = 0;
     for (cpu = 0; cpu < common -> num_procs; cpu ++) {
-      if (common -> node_info[node] & common -> avail & (1UL << cpu)) {
+      if (common -> node_info[node] & common -> avail & (((unsigned long long int) 1) << cpu)) {
 	common -> cpu_info[count] = WRITE_CORE(core) | WRITE_NODE(node) | WRITE_CPU(cpu);
 	count ++;
 	core ++;
@@ -311,10 +327,10 @@
 
 static void disable_hyperthread(void) {
 
-  unsigned long share;
+  unsigned long long int share;
   int cpu;
 
-  common -> avail = (1UL << common -> num_procs) - 1;
+  common -> avail = (((unsigned long long int) 1) << common -> num_procs) - 1;
 
 #ifdef DEBUG
   fprintf(stderr, "\nAvail CPUs    : %04lx.\n", common -> avail);
@@ -328,10 +344,10 @@
       
 #ifdef DEBUG
       fprintf(stderr, "Detected Hyper Threading on CPU %4x; disabled CPU %04lx.\n",
-	      cpu, share & ~(1UL << cpu));
+	      cpu, share & ~(((unsigned long long int) 1) << cpu));
 #endif
       
-      common -> avail &= ~((share & ~(1UL << cpu)));
+      common -> avail &= ~((share & ~(((unsigned long long int) 1) << cpu)));
     }
   }
 }
@@ -343,7 +359,7 @@
     fprintf(stderr, "CPU mask                  : %04lx.\n\n", *(unsigned long *)&cpu_orig_mask[0]);
 #endif
 
-  lprocmask = (1UL << common -> final_num_procs) - 1;
+  lprocmask = (((unsigned long long int) 1) << common -> final_num_procs) - 1;
 
 #ifndef USE_OPENMP
   lprocmask &= *(unsigned long *)&cpu_orig_mask[0];
@@ -383,7 +399,7 @@
     fprintf(stderr, "Node mask = %lx\n", lnodemask);
 #endif
     
-    my_set_mempolicy(MPOL_INTERLEAVE, &lnodemask, sizeof(lnodemask) * 8);
+    //my_set_mempolicy(MPOL_INTERLEAVE, &lnodemask, sizeof(lnodemask) * 8);
 
     numnodes = popcount(lnodemask);
   }
@@ -441,7 +457,7 @@
 
   int cpu, id, mapping;
 
-  cpu = 0;
+  cpu = common->final_num_procs - 1;
   mapping = 0;
 
   do {
@@ -451,7 +467,7 @@
       if (is_dead(id)) common -> cpu_use[cpu] = 0;
     }
 
-    if ((common -> cpu_use[cpu] == 0) && (lprocmask & (1UL << cpu))) {
+    if ((common -> cpu_use[cpu] == 0) && (lprocmask & (((unsigned long long int) 1) << cpu))) {
 
       common -> cpu_use[cpu] = pshmid;
       cpu_mapping[mapping] = READ_CPU(common -> cpu_info[cpu]);
@@ -460,9 +476,9 @@
       mapping ++;
     }
 
-    cpu ++;
+    cpu --;
     
-  } while ((mapping < numprocs) && (cpu < common -> final_num_procs));
+  } while ((mapping < numprocs) && (cpu >= 0));
   
   disable_mapping = 0;
 
@@ -486,7 +502,7 @@
 int get_num_nodes(void)  { return numnodes; }
 int get_node_equal(void) { 
 
-  return (((blas_cpu_number % numnodes) == 0) && node_equal);
+  return (((blas_cpu_number % numnodes) == 0) && node_equal && caldgemm_reserve_cpus == 0);
   
 }
 
@@ -534,11 +550,13 @@
 void gotoblas_affinity_init(void) {
 
   int cpu, num_avail;
+  int i;
 #ifndef USE_OPENMP
   cpu_set_t cpu_mask;
 #endif
 
   if (initialized) return;
+  for (i = 0;i < MAX_CPUS;i++) reserved_cpu_cores[i] = 0;
 
   initialized = 1;
 
diff -u -r gotoblas_org/GotoBLAS2/driver/others/memory.c GotoBLAS2/driver/others/memory.c
--- gotoblas_org/GotoBLAS2/driver/others/memory.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/driver/others/memory.c	2011-03-29 10:50:43.686531848 +0200
@@ -37,7 +37,6 @@
 /*********************************************************************/
 
 #undef  DEBUG
-
 #include "common.h"
 
 #ifdef OS_WINDOWS
@@ -109,6 +108,11 @@
 gotoblas_t *gotoblas = NULL;
 #endif
 
+#ifdef DEBUG
+int alloc_area[NUM_BUFFERS];
+int alloc_used[NUM_BUFFERS];
+#endif
+
 #ifndef SMP
 
 #define blas_cpu_number 1
@@ -174,6 +178,8 @@
 #endif
 
 int blas_cpu_number  = 0;
+int caldgemm_reserve_cpus = 0;
+int caldgemm_restrict_cpus = 0;
 int blas_num_threads = 0;
 
 int  goto_get_num_procs  (void) {
@@ -912,7 +918,9 @@
 
       while ((func != NULL) && (map_address == (void *) -1)) {
 
-	map_address = (*func)((void *)base_address);
+      LOCK_COMMAND(&alloc_lock);
+      map_address = (*func)((void *)base_address);
+      UNLOCK_COMMAND(&alloc_lock);
 
 #ifdef ALLOC_DEVICEDRIVER
 	if ((*func ==  alloc_devicedirver) && (map_address == (void *)-1)) {
@@ -936,7 +944,7 @@
       }
 
 #ifdef DEBUG
-      printf("  Success -> %08lx\n", map_address);
+      printf("  Success -> %08lx\n", (unsigned long int) map_address);
 #endif
       if (((BLASLONG) map_address) == -1) base_address = 0UL;
 
diff -u -r gotoblas_org/GotoBLAS2/interface/axpy.c GotoBLAS2/interface/axpy.c
--- gotoblas_org/GotoBLAS2/interface/axpy.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/interface/axpy.c	2011-03-29 10:55:57.651532068 +0200
@@ -79,7 +79,15 @@
   if (incy < 0) y -= (n - 1) * incy;
 
 #ifdef SMP
-  nthreads = num_cpu_avail(1);
+  if (caldgemm_restrict_cpus)
+  {
+    nthreads = 8;
+    if (nthreads > num_cpu_avail(1)) nthreads = num_cpu_avail(1);
+  }
+  else
+  {
+    nthreads = num_cpu_avail(1);
+  }
 
   if (nthreads == 1) {
 #endif
diff -u -r gotoblas_org/GotoBLAS2/interface/gemm.c GotoBLAS2/interface/gemm.c
--- gotoblas_org/GotoBLAS2/interface/gemm.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/interface/gemm.c	2011-04-05 21:47:54.575951460 +0200
@@ -398,6 +398,20 @@
 
   args.common = NULL;
   args.nthreads = num_cpu_avail(3);
+  if (caldgemm_restrict_cpus)
+  {
+    long long int tflops = (long long int) args.m * (long long int) args.n * (long long int) args.k;
+    if (tflops <= 16384) args.nthreads = 1;
+    else if (tflops <= 65536) args.nthreads = 2;
+    else if (tflops < 200000 || (tflops > 2000000 && tflops < 4000000)) args.nthreads = 3;
+    else if (tflops <= 2000000) args.nthreads = 4;
+    else if (tflops <= 26542080) args.nthreads = 8;
+    else if (tflops <= 56623104) args.nthreads = 12;
+    else if (tflops <= 89915392) args.nthreads = 16;
+    else if (tflops <= 262144000) args.nthreads = 20;
+
+    if (args.nthreads > num_cpu_avail(3)) args.nthreads = num_cpu_avail(3);
+  }
 
  if (args.nthreads == 1) {
 #endif
diff -u -r gotoblas_org/GotoBLAS2/interface/gemv.c GotoBLAS2/interface/gemv.c
--- gotoblas_org/GotoBLAS2/interface/gemv.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/interface/gemv.c	2011-03-29 10:56:51.093543219 +0200
@@ -211,8 +211,30 @@
   buffer = (FLOAT *)blas_memory_alloc(1);
 
 #ifdef SMP
-  nthreads = num_cpu_avail(2);
-
+  
+  if (caldgemm_restrict_cpus)
+  {
+    if (m >= 4 * n)
+    {
+	long long int tflops = (long long int) m * 64;
+	if (tflops <= 458752) nthreads = 4;
+	else if (tflops <= 655360) nthreads = 8;
+	else nthreads = 24;
+    }
+    else
+    {
+	long long int tflops = (long long int) m * (long long int) n;
+	if (tflops < 102400) nthreads = 1;
+	else if (tflops < 3686400) nthreads = 3;
+	else nthreads = 4;
+    }
+    if (nthreads > 8) nthreads = 8;
+    if (nthreads > num_cpu_avail(2)) nthreads = num_cpu_avail(2);
+  }
+  else
+  {
+    nthreads = num_cpu_avail(2);
+  }
   if (nthreads == 1) {
 #endif
     
diff -u -r gotoblas_org/GotoBLAS2/interface/scal.c GotoBLAS2/interface/scal.c
--- gotoblas_org/GotoBLAS2/interface/scal.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/interface/scal.c	2011-03-29 10:55:33.693531905 +0200
@@ -76,7 +76,15 @@
 
 
 #ifdef SMP
-  nthreads = num_cpu_avail(1);
+  if (caldgemm_restrict_cpus)
+  {
+    nthreads = 8;
+    if (nthreads > num_cpu_avail(1)) nthreads = num_cpu_avail(1);
+  }
+  else
+  {
+    nthreads = num_cpu_avail(1);
+  }
 
   if (nthreads == 1) {
 #endif
diff -u -r gotoblas_org/GotoBLAS2/interface/trsm.c GotoBLAS2/interface/trsm.c
--- gotoblas_org/GotoBLAS2/interface/trsm.c	2010-11-05 14:57:49.000000000 +0100
+++ GotoBLAS2/interface/trsm.c	2011-03-29 10:54:56.886531912 +0200
@@ -362,6 +362,16 @@
   mode |= (side  << BLAS_RSIDE_SHIFT);
 
   args.nthreads = num_cpu_avail(3);
+  if (caldgemm_restrict_cpus)
+  {
+    long long int tflops = (long long int) args.n * (long long int) args.n * (long long int) args.m;
+    if (tflops <= 32768) args.nthreads = 1;
+    else if (tflops <= 110592) args.nthreads = 3;
+    else if (tflops <= 100000000) args.nthreads = 4;
+    else if (tflops <= 1000000000) args.nthreads = 16;
+    if (args.nthreads > 8) args.nthreads = 8;
+    if (args.nthreads > num_cpu_avail(3)) args.nthreads = num_cpu_avail(3);
+  }
 
   if (args.nthreads == 1) {
 #endif
Only in GotoBLAS2: lapack-3.1.1.tgz
diff -u -r gotoblas_org/GotoBLAS2/Makefile GotoBLAS2/Makefile
--- gotoblas_org/GotoBLAS2/Makefile	2010-01-20 21:54:38.000000000 +0100
+++ GotoBLAS2/Makefile	2011-03-29 11:03:33.454897208 +0200
@@ -13,9 +13,14 @@
 
 SUBDIRS	= $(BLASDIRS) lapack
 
+ifdef NO_SELFTEST
+SUBDIRS_ALL = $(SUBDIRS) exports ../laswp ../bench
+.PHONY : all libs netlib shared
+else
 SUBDIRS_ALL = $(SUBDIRS) test ctest exports benchmark ../laswp ../bench
-
 .PHONY : all libs netlib test ctest shared
+endif
+
 .NOTPARALLEL : all libs prof lapack-test
 
 all :: libs netlib tests shared
@@ -71,6 +76,7 @@
 endif
 
 tests :
+ifndef NO_SELFTEST
 ifndef NOFORTRAN
 ifndef TARGET
 ifndef CROSS
@@ -83,6 +89,7 @@
 endif
 endif
 endif
+endif
 endif
 
 libs :
diff -u -r gotoblas_org/GotoBLAS2/Makefile.rule GotoBLAS2/Makefile.rule
--- gotoblas_org/GotoBLAS2/Makefile.rule	2010-02-05 17:02:04.000000000 +0100
+++ GotoBLAS2/Makefile.rule	2011-06-06 18:20:37.557024686 +0200
@@ -7,7 +7,7 @@
 
 # You can specify the target architecture, otherwise it's
 # automatically detected.
-# TARGET = PENRYN
+TARGET = BARCELONA
 
 # If you want to support multiple architecture in one binary
 # DYNAMIC_ARCH = 1
@@ -59,6 +59,12 @@
 # If you want to disable CPU/Memory affinity on Linux.
 # NO_AFFINITY = 1
 
+# Do not set the memory policy to interleaving automatically
+NO_MEMPOLICY = 1
+
+# Do not run selftest after compilation
+NO_SELFTEST = 1
+
 # If you would like to know minute performance report of GotoBLAS.
 # FUNCTION_PROFILE = 1
 
diff -u -r gotoblas_org/GotoBLAS2/Makefile.system GotoBLAS2/Makefile.system
--- gotoblas_org/GotoBLAS2/Makefile.system	2010-01-28 21:11:08.000000000 +0100
+++ GotoBLAS2/Makefile.system	2011-02-16 10:22:24.991642328 +0100
@@ -570,6 +570,10 @@
 endif
 endif
 
+ifdef NO_MEMPOLICY
+CCOMMON_OPT    += -DNO_MEMPOLICY
+endif
+
 ifdef NO_AFFINITY
 CCOMMON_OPT	+= -DNO_AFFINITY
 endif
