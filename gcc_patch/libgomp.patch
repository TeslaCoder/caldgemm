--- ../gcc-4.6.1/libgomp/team.c	2009-05-20 22:54:45.000000000 +0200
+++ libgomp/team.c	2012-07-26 16:23:14.203545586 +0200
@@ -29,6 +29,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#define GOMP_KEEP_THREAD ((void*) (size_t) -1)
+
 /* This attribute contains PTHREAD_CREATE_DETACHED.  */
 pthread_attr_t gomp_thread_attr;
 
@@ -116,7 +118,10 @@
 	  gomp_team_barrier_wait (&team->barrier);
 	  gomp_finish_task (task);
 
-	  gomp_barrier_wait (&pool->threads_dock);
+	  do
+	  {
+	    gomp_barrier_wait (&pool->threads_dock);
+	  } while (thr->fn == GOMP_KEEP_THREAD);
 
 	  local_fn = thr->fn;
 	  local_data = thr->data;
@@ -258,8 +263,9 @@
   struct gomp_task_icv *icv;
   bool nested;
   struct gomp_thread_pool *pool;
-  unsigned i, n, old_threads_used = 0;
+  unsigned i, j, n, old_threads_used = 0;
   pthread_attr_t thread_attr, *attr;
+  
 
   thr = gomp_thread ();
   nested = thr->ts.team != NULL;
@@ -346,6 +352,11 @@
 	  nthr->data = data;
 	  team->ordered_release[i] = &nthr->release;
 	}
+	for (j = i;j < old_threads_used;j++)
+	{
+	  nthr = pool->threads[j];
+	  nthr->fn = GOMP_KEEP_THREAD;
+	}
 
       if (i == nthreads)
 	goto do_release;
@@ -434,7 +445,7 @@
      that should arrive back at the end of this team.  The extra
      threads should be exiting.  Note that we arrange for this test
      to never be true for nested teams.  */
-  if (__builtin_expect (nthreads < old_threads_used, 0))
+  /*if (__builtin_expect (nthreads < old_threads_used, 0))
     {
       long diff = (long) nthreads - (long) old_threads_used;
 
@@ -447,7 +458,8 @@
       gomp_managed_threads += diff;
       gomp_mutex_unlock (&gomp_remaining_threads_lock);
 #endif
-    }
+    }*/
+    if (!nested && old_threads_used > nthreads) pool->threads_used = old_threads_used;
 }
 
 
